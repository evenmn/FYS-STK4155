\section{Code} \label{sec:code}
I will briefly describe the code. Written in Python.

\subsection{Code structure} \label{sec:structure}
To keep the code neat and clean we decided to write object oriented code, although we do not have that many functions. The entire code used in this project consists of a main.py which call the other functions, a Franke function (franke.py), a class for 2D regression (regression\_2D.py) and a class containing resampling techniques (resampling.py). See figure \eqref{fig:codestructure} for code structure.
\begin{figure}
\centering
\begin{tikzpicture}[auto,node distance=1.5cm]

  % Create entity node
  \node[entity] (node1) {main.py}
    child[grow=up,level distance=2cm] {node[attribute] {franke.py}};
  
  % Establish relationships
  \node[relationship] (rel1) [below right = of node1] {regression\_2D.py};
  \node[relationship] (rel2) [below left = of node1] {resampling.py};
  
  % Draw paths
  \path (rel1) edge node {} (node1);
  \path (rel2) edge node {} (node1);

\end{tikzpicture}
\caption{Code structure}
\label{fig:codestructure}
\end{figure}

\subsection{Implementation and optimization} \label{sec:implementation}
To get a code which provides good performance, we need to be thoughtful when implementing it. The loops are often bottlenecks are often, so by replacing loops with vector operations we can save a lot of time. An example on this, is when we calculate the mean square error,
\begin{equation}
\text{MSE}(\vec{y})=\sum_i\bigg(y_i-\beta_0-\sum_jX_{ij}\beta_j\bigg)^2,
\end{equation}
where $\vec{y}$ and $\vec{\beta}$ are vectors and $\hat{X}$ is a matrix. For implementing this directly, we a double loops, which can be slow for large systems. A better solution would be to exploit the linear algebra properties of vectors:

\begin{equation}
\text{MSE}(\vec{y})=(\vec{y}-\hat{X}^T\vec{\beta})^T\cdot(\vec{y}-\hat{X}^T\vec{\beta})
\end{equation}
which is usually much faster. 